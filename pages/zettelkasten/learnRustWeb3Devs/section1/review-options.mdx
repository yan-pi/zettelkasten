---
title: 'Learn Rust with Web3 Devs -  Revis√£o de `Option` e Tratamento de `Option`'
date: 2024/05/18
description: 'Section 1 - review of blockchain and Rust principles'
tags: ['Zettelkasten', 'Rust', 'Web3', 'Blockchain']
type: 'post'
author: 'Yan Fernandes'
---

## Revis√£o de `Option` e Tratamento de `Option`

Um dos principais princ√≠pios de Rust √© remover comportamento indefinido do seu c√≥digo.

Uma maneira de ocorrer comportamento indefinido √© permitindo que estados como existam. Rust previne isso fazendo com que
o usu√°rio trate explicitamente todos os casos, e √© aqui que entra a cria√ß√£o do tipo`Option`. Dedique um momento para
revisar a
[se√ß√£o sobre `Option`](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html?highlight=option#the-option-enum-and-its-advantages-over-null-values)
do livro de Rust, se necess√°rio.

A API do `BTreeMap` usa um `Option` ao ler valores do mapa, j√° que pode ser que voc√™ pe√ßa para ler o valor de alguma
chave que voc√™ n√£o definiu. Por exemplo:

```rust
use std::collections::BTreeMap;

let mut map = BTreeMap::new();
map.insert("alice", 100);
assert_eq!(map.get(&"alice"), Some(&100));
assert_eq!(map.get(&"bob"), None);
```

Uma vez que temos um tipo `Option`, existem muitas maneiras diferentes de interagir com ele usando Rust.

A maneira mais verbosa √© usando uma declara√ß√£o de `match`:

```rust
let maybe_value = map.get(&"alice");
match maybe_value {
    Some(value) => {
        // fazer algo com o `value`
    },
    None => {
        // talvez retornar um erro j√° que n√£o havia valor l√°
    }
}
```

> üö® Alerta: O que voc√™ N√ÉO DEVE fazer √© usar `unwrap()` cegamente em op√ß√µes. Isso resultar√° em um `panic` no seu
> c√≥digo, o que √© exatamente o tipo de coisa que Rust foi projetado para prevenir! Em vez disso, voc√™ deve sempre tratar
> explicitamente todos os seus diferentes casos l√≥gicos, e se deixar que Rust fa√ßa seu trabalho, seu c√≥digo ser√° super
> seguro.

No contexto do que estamos projetando para o m√≥dulo de saldos, temos um mapa que possui um n√∫mero arbitr√°rio de chaves
de usu√°rio e seus valores de saldo.

O que devemos fazer quando lemos o saldo de um usu√°rio que n√£o existe no nosso mapa?

Bem, o truque aqui √© que no contexto das blockchains, um usu√°rio ter `None` saldo e um usu√°rio ter `0` saldo √© a mesma
coisa. Claro, h√° alguns detalhes mais finos a serem expressos entre um usu√°rio que existe em nosso estado com valor 0 e
um usu√°rio que n√£o existe de todo, mas para os prop√≥sitos de nossas APIs, podemos trat√°-los da mesma forma.

Como isso se parece?

Bem, podemos usar `unwrap_or(...)` para tratar essa condi√ß√£o com seguran√ßa e tornar nossas futuras APIs mais ergon√¥micas
de usar. Por exemplo:

```rust
use std::collections::BTreeMap;

let mut map = BTreeMap::new();
map.insert("alice", 100);
assert_eq!(*map.get(&"alice").unwrap_or(&0), 100);
assert_eq!(*map.get(&"bob").unwrap_or(&0), 0);
```

Como voc√™ pode ver, ao usar `unwrap_or(&0)` ap√≥s ler do nosso mapa, somos capazes de transformar nosso `Option` em um
inteiro b√°sico, onde usu√°rios com algum valor t√™m seu valor exposto e usu√°rios com `None` s√£o transformados em `0`.

Vamos ver como isso pode ser usado a seguir.

Definindo e Lendo Saldos de Usu√°rios Como voc√™ pode ver, nossa m√°quina de estados inicial come√ßa com todos sem saldo.

Para tornar nosso m√≥dulo √∫til, precisamos ter pelo menos algumas fun√ß√µes que nos permitam criar novos saldos para
usu√°rios e ler esses saldos.

Crie uma nova fun√ß√£o dentro de `impl Pallet` chamada `fn set_balance`:

```rust
impl Pallet {
    pub fn set_balance(&mut self, who: &String, amount: u128) {
        self.balances.insert(who.clone(), amount);
    }

    // -- snip --
}
```

Como voc√™ pode ver, esta fun√ß√£o simplesmente recebe informa√ß√µes sobre qual usu√°rio queremos definir o saldo e qual saldo
queremos definir. Isso ent√£o empurra essa informa√ß√£o para nosso `BTreeMap`, e isso √© tudo.

Crie uma nova fun√ß√£o dentro de `impl Pallet` chamada `fn balance`:

```rust
impl Pallet {
    pub fn balance(&self, who: &String) -> u128 {
        *self.balances.get(&who).unwrap_or(&0)
    }
}
```

Como voc√™ pode ver, esta fun√ß√£o nos permite ler o saldo dos usu√°rios em nosso mapa. A fun√ß√£o permite que voc√™ insira
algum usu√°rio e n√≥s retornaremos o saldo dele.

> üö® Alerta: Note que fazemos nosso pequeno truque aqui! Em vez de expor uma API que for√ßa o usu√°rio a lidar com um >
> `Option`, somos capazes de fazer nossa API sempre retornar um u128 convertendo qualquer usu√°rio com valor None em 0.
